package sudoku

import (
	"testing"
)

func TestSolve(t *testing.T) {
	type args struct {
		board Board
	}
	tests := []struct {
		name   string
		input  string
		output string
		valid  bool
	}{
		{
			"completed puzzle",
			"974236158638591742125487936316754289742918563589362417867125394253649871491873625",
			"974236158638591742125487936316754289742918563589362417867125394253649871491873625",
			true,
		},
		{
			"last empty square",
			"2564891733746159829817234565932748617128.6549468591327635147298127958634849362715",
			"256489173374615982981723456593274861712836549468591327635147298127958634849362715",
			true,
		},
		{
			"naked singles",
			"3.542.81.4879.15.6.29.5637485.793.416132.8957.74.6528.2413.9.655.867.192.965124.8",
			"365427819487931526129856374852793641613248957974165283241389765538674192796512438",
			true,
		},
		{
			"hidden singles",
			"..2.3...8.....8....31.2.....6..5.27..1.....5.2.4.6..31....8.6.5.......13..531.4..",
			"672435198549178362831629547368951274917243856254867931193784625486592713725316489",
			true,
		},
		{
			"unsolvable square",
			"..9.287..8.6..4..5..3.....46.........2.71345.........23.....5..9..4..8.7..125.3..",
			"",
			false,
		},
		{
			"unsolvable box",
			".9.3....1....8..46......8..4.5.6..3...32756...6..1.9.4..1......58..2....2....7.6.",
			"",
			false,
		},
		{
			"unsolvable column",
			"....41....6.....2...2......32.6.........5..417.......2......23..48......5.1..2...",
			"",
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			grid := BoardFromString(tt.input)
			res := Solve(grid)
			if res != tt.valid {
				t.Errorf("Solve() = %v, want %v", res, tt.valid)
			}
			if tt.valid && grid.String() != tt.output {
				t.Errorf("grid not equal\nwant:\t%v\ngot:\n%v", tt.output, grid.String())
			}
		})
	}
}
